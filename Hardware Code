Part 1 (Arduino)
void setup() {
 Serial.begin(115200); // Initialize serial communication at 115200 baud rate
}
void loop() {
 int ppgMother = analogRead(A0); // Read analog value from A0 (mother's finger)
 int ppgAbdomen = analogRead(A1); // Read analog value from A1 (abdomen)
 Serial.print(ppgMother); // Send the mother's PPG signal
 Serial.print(","); // Send a delimiter
 Serial.println(ppgAbdomen); // Send the abdomen PPG signal
 delay(10); // Small delay to simulate sampling rate
}
Part 2 (python code)
import serial
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import find_peaks, butter, filtfilt, lfilter
# Serial port setup (replace 'COM7' with your Arduino's serial port)
ser = serial.Serial('COM4', 9600)
# Parameters
numsamples = 1500 # Number of samples to read
samplingrate = 100 # Sampling rate in Hz
lowcutoff = 0.5 # Low cutoff frequency for bandpass filter in Hz
highcutoff = 3.0 # High cutoff frequency for bandpass filter in Hz
# Initialize data arrays
data_maternal_abdomen = np.zeros(numsamples)
data_maternal_finger = np.zeros(numsamples)
# Bandpass filter setup
def butter_bandpass(lowcut, highcut, fs, order=5):
 nyquist = 0.5 * fs
 low = lowcut / nyquist
 high = highcut / nyquist
 b, a = butter(order, [low, high], btype='band')
 return b, a
def bandpass_filter(data, lowcut, highcut, fs, order=5):
 b, a = butter_bandpass(lowcut, highcut, fs, order=order)
 y = filtfilt(b, a, data)
return y
# Read data from the serial port
def read_se_data(ser, numsamples):
 data_abdomen = np.zeros(numsamples)
 data_finger = np.zeros(numsamples)
 for i in range(numsamples):
 try:
 line = ser.readline().decode('utf-8').strip()
 abdomen, finger = map(int, line.split(',')) # Assuming the data is sent as "abdomen,finger"
 data_abdomen[i] = abdomen
 data_finger[i] = finger
 except ValueError:
 pass
 return data_abdomen, data_finger
# Apply adaptive filtering
def adaptive_filtering(reference_signal, primary_signal, mu=0.01, order=5):
 w = np.zeros(order)
 n = len(primary_signal)
 y = np.zeros(n)
 e = np.zeros(n)
 for i in range(order, n):
 x = reference_signal[i-order:i]
 y[i] = np.dot(w, x)
 e[i] = primary_signal[i] - y[i]
 w += 2 * mu * e[i] * x
 return e
# Function to calculate heart rate from PPG signal
def calculate_heart_rate(signal, samplingrate):
 peaks, _ = find_peaks(signal, distance=samplingrate/2)
peak_intervals = np.diff(peaks) / samplingrate
 if len(peak_intervals) > 0:
 average_peak_interval = np.mean(peak_intervals)
 heart_rate_bpm = 60 / average_peak_interval
 return heart_rate_bpm, peaks
 else:
 return None, []
# Main loop to read data and calculate heart rates
while True:
 # Read data from serial port
 data_maternal_abdomen, data_maternal_finger = read_se_data(ser, numsamples)
 # Apply bandpass filter
 filtered_abdomen = bandpass_filter(data_maternal_abdomen, lowcutoff, highcutoff, samplingrate)
 filtered_finger = bandpass_filter(data_maternal_finger, lowcutoff, highcutoff, samplingrate)
# Apply adaptive filtering to isolate fetal signal
 fetal_signal = adaptive_filtering(filtered_finger, filtered_abdomen)
 # Calculate maternal heart rates
 maternal_abdomen_hr, abdomen_peaks = calculate_heart_rate(filtered_abdomen, samplingrate)
 maternal_finger_hr, finger_peaks = calculate_heart_rate(filtered_finger, samplingrate)
 # Calculate fetal heart rate
 fetal_hr, fetal_peaks = calculate_heart_rate(fetal_signal, samplingrate)
 # Print heart rates
 if maternal_abdomen_hr is not None:
 print(f"Maternal Heart Rate (Abdomen): {maternal_abdomen_hr:.2f} BPM")
 else:
 print("No peaks detected in maternal abdomen signal")
if maternal_finger_hr is not None:
 print(f"Maternal Heart Rate (Finger): {maternal_finger_hr:.2f} BPM")
 else:
 print("No peaks detected in maternal finger signal")
 if fetal_hr is not None:
 print(f"Estimated Fetal Heart Rate: {fetal_hr:.2f} BPM")
 else:
 print("No peaks detected in fetal signal")
 # Plotting for visualization (optional)
 plt.figure(figsize=(12, 9))
 plt.subplot(4, 1, 1)
 plt.plot(data_maternal_abdomen, label='Maternal Abdomen PPG Signal')
 plt.title('Maternal Abdomen PPG Signal')
plt.subplot(4, 1, 2)
 plt.plot(data_maternal_finger, label='Maternal Finger PPG Signal')
 plt.title('Maternal Finger PPG Signal')
 plt.subplot(4, 1, 3)
 plt.plot(filtered_abdomen, label='Filtered Maternal Abdomen Signal', linewidth=2)
 plt.plot(abdomen_peaks, filtered_abdomen[abdomen_peaks], 'ro', label='Detected Peaks')
 plt.title('Filtered Maternal Abdomen Signal and Detected Peaks')
 plt.subplot(4, 1, 4)
 plt.plot(fetal_signal, label='Isolated Fetal Signal', linewidth=2)
 plt.plot(fetal_peaks, fetal_signal[fetal_peaks], 'ro', label='Detected Peaks')
 plt.title('Isolated Fetal Signal and Detected Peaks')
 plt.xlabel('Sample Number')
 plt.ylabel('Amplitude')
plt.legend()
 plt.tight_layout()
 plt.show()
Code for LCD Interfacing Circuit
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
// Initialize the LCD with the I2C address (usually 0x27 or 0x3F)
LiquidCrystal_I2C lcd(0x27, 16, 2); 
void setup() {
 lcd.init(); // Initialize the LCD
 lcd.backlight(); // Turn on the backlight
 lcd.print("Heart Rate:"); // Display initial message
}
void loop() { 
 // Clear the LCD and display the heart rate
lcd.setCursor(0, 1); // Move cursor to the second row
 lcd.print(heartRate); // Display heart rate value
delay(1000); // Delay for readability (adjust as needed)
}                                                              
